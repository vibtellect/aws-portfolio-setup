import { Construct } from 'constructs';
import * as cdk from 'aws-cdk-lib';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as kms from 'aws-cdk-lib/aws-kms';

/**
 * Properties for DynamoDbTableStandard
 *
 * @example
 * ```ts
 * const props: DynamoDbTableStandardProps = {
 *   partitionKey: {
 *     name: 'userId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 *   sortKey: {
 *     name: 'todoId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 * };
 * ```
 */
export interface DynamoDbTableStandardProps {
  /**
   * Table name
   *
   * WARUM optional?
   * - CDK generiert automatisch eindeutigen Namen
   * - Nur setzen wenn spezifische Namenskonvention benötigt wird
   *
   * @default - Auto-generated by CDK
   */
  readonly tableName?: string;

  /**
   * Partition key (erforderlich)
   *
   * WARUM erforderlich?
   * - DynamoDB benötigt mindestens einen Partition Key
   * - Definiert wie Daten verteilt werden
   *
   * BEISPIEL:
   * ```ts
   * partitionKey: {
   *   name: 'userId',
   *   type: dynamodb.AttributeType.STRING,
   * }
   * ```
   */
  readonly partitionKey: dynamodb.Attribute;

  /**
   * Sort key (optional)
   *
   * WARUM optional?
   * - Nicht alle Tables benötigen Sort Key
   * - Nur wenn hierarchische Daten (z.B. userId + todoId)
   *
   * BEISPIEL:
   * ```ts
   * sortKey: {
   *   name: 'timestamp',
   *   type: dynamodb.AttributeType.NUMBER,
   * }
   * ```
   *
   * @default - No sort key
   */
  readonly sortKey?: dynamodb.Attribute;

  /**
   * Billing mode
   *
   * WARUM PAY_PER_REQUEST als Default?
   * - Kostenoptimiert für variable Workloads
   * - Keine Kapazitätsplanung nötig
   * - Free Tier: 25 WCU/RCU kostenlos
   *
   * @default BillingMode.PAY_PER_REQUEST
   */
  readonly billingMode?: dynamodb.BillingMode;

  /**
   * Read capacity (nur für PROVISIONED mode)
   *
   * @default - Not set (PAY_PER_REQUEST)
   */
  readonly readCapacity?: number;

  /**
   * Write capacity (nur für PROVISIONED mode)
   *
   * @default - Not set (PAY_PER_REQUEST)
   */
  readonly writeCapacity?: number;

  /**
   * Encryption key
   *
   * WARUM optional?
   * - AWS Managed Encryption ist Standard
   * - Customer Managed nur wenn Compliance nötig
   *
   * @default - AWS managed encryption
   */
  readonly encryptionKey?: kms.IKey;

  /**
   * Point-in-Time Recovery
   *
   * WARUM false als Default?
   * - Kostet extra (Backup Storage)
   * - Für Dev/Test meist nicht nötig
   * - Prod: empfohlen, aber optional
   *
   * @default false
   */
  readonly pointInTimeRecovery?: boolean;

  /**
   * Stream specification
   *
   * WARUM optional?
   * - Nur wenn Event-Driven Patterns benötigt
   * - z.B. Lambda Triggers, CDC
   *
   * @default - No stream
   */
  readonly stream?: dynamodb.StreamViewType;

  /**
   * Removal policy
   *
   * WARUM auto-detect?
   * - Dev: DESTROY (schnelles Cleanup)
   * - Prod: RETAIN (Datenschutz)
   *
   * @default - Auto-detect based on stack name
   */
  readonly removalPolicy?: cdk.RemovalPolicy;
}

/**
 * DynamoDB Table mit Production Best Practices
 *
 * WARUM dieser Construct?
 * 1. Kostenoptimierung: PAY_PER_REQUEST als Default
 * 2. Sicherheit: Encryption at Rest immer aktiviert
 * 3. Wartbarkeit: Environment-aware RemovalPolicy
 *
 * WAS macht er?
 * - Erstellt DynamoDB Table mit Best Practices
 * - Encryption at Rest (AWS oder Customer Managed)
 * - Optional: Streams, PITR, GSIs
 * - Environment-aware RemovalPolicy
 *
 * @example
 * ```ts
 * // Todo App Pattern
 * const table = new DynamoDbTableStandard(this, 'TodoTable', {
 *   partitionKey: {
 *     name: 'userId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 *   sortKey: {
 *     name: 'todoId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 *   pointInTimeRecovery: true, // Prod empfohlen
 * });
 * ```
 */
export class DynamoDbTableStandard extends Construct {
  /**
   * Die erstellte DynamoDB Table
   *
   * WARUM public?
   * - Lambda Functions benötigen Zugriff
   * - Für Custom Policies/Permissions
   */
  public readonly table: dynamodb.Table;

  /**
   * ARN der Table
   *
   * WARUM extra Property?
   * - Häufig benötigt für IAM Policies
   * - Für Cross-Account Zugriff
   */
  public readonly tableArn: string;

  /**
   * Name der Table
   *
   * WARUM extra Property?
   * - Für Lambda Environment Variables
   * - Für CLI-Scripts
   */
  public readonly tableName: string;

  /**
   * Stream ARN (falls Stream aktiviert)
   *
   * @default - undefined if no stream
   */
  public readonly tableStreamArn?: string;

  constructor(scope: Construct, id: string, props: DynamoDbTableStandardProps) {
    super(scope, id);

    // ========================================
    // 1. VALIDIERUNG
    // ========================================

    this.validateProps(props);

    // ========================================
    // 2. REMOVAL POLICY (Environment-aware)
    // ========================================

    const removalPolicy = this.determineRemovalPolicy(props.removalPolicy);

    // ========================================
    // 3. ENCRYPTION
    // ========================================

    const encryption = props.encryptionKey
      ? dynamodb.TableEncryption.CUSTOMER_MANAGED
      : dynamodb.TableEncryption.AWS_MANAGED;

    // ========================================
    // 4. DYNAMODB TABLE ERSTELLEN
    // ========================================

    this.table = new dynamodb.Table(this, 'Table', {
      tableName: props.tableName,

      // Keys
      partitionKey: props.partitionKey,
      sortKey: props.sortKey,

      // Billing
      billingMode: props.billingMode ?? dynamodb.BillingMode.PAY_PER_REQUEST,
      readCapacity: props.readCapacity,
      writeCapacity: props.writeCapacity,

      // Encryption
      encryption: encryption,
      encryptionKey: props.encryptionKey,

      // Backup & Recovery
      pointInTimeRecovery: props.pointInTimeRecovery ?? false,

      // Stream
      stream: props.stream,

      // Lifecycle
      removalPolicy: removalPolicy,
    });

    // ========================================
    // 5. TAGS
    // ========================================

    cdk.Tags.of(this.table).add('ManagedBy', 'CDK');
    cdk.Tags.of(this.table).add('Construct', 'DynamoDbTableStandard');

    // ========================================
    // 6. OUTPUTS
    // ========================================

    this.tableArn = this.table.tableArn;
    this.tableName = this.table.tableName;
    this.tableStreamArn = this.table.tableStreamArn;
  }

  /**
   * Validiert die Props
   *
   * WARUM validieren?
   * - Frühzeitiges Feedback
   * - Bessere Fehlermeldungen
   * - Verhindert AWS API Errors
   */
  private validateProps(props: DynamoDbTableStandardProps): void {
    // Prüfe Partition Key
    if (!props.partitionKey) {
      throw new Error('Partition key is required');
    }

    // Prüfe Table-Name (AWS Limits)
    if (props.tableName && props.tableName.length > 255) {
      throw new Error('Table name must be <= 255 characters');
    }

    // Prüfe Table-Name Pattern (AWS erlaubt nur bestimmte Zeichen)
    if (props.tableName) {
      const validPattern = /^[a-zA-Z0-9._-]+$/;
      if (!validPattern.test(props.tableName)) {
        throw new Error('Table name must match pattern: [a-zA-Z0-9._-]+');
      }
    }

    // Prüfe Billing Mode + Capacity Settings
    if (props.billingMode === dynamodb.BillingMode.PROVISIONED) {
      if (!props.readCapacity || !props.writeCapacity) {
        throw new Error(
          'readCapacity and writeCapacity are required for PROVISIONED billing mode'
        );
      }
    }

    // Prüfe Capacity Settings bei PAY_PER_REQUEST
    if (
      props.billingMode === dynamodb.BillingMode.PAY_PER_REQUEST ||
      !props.billingMode
    ) {
      if (props.readCapacity || props.writeCapacity) {
        throw new Error(
          'readCapacity and writeCapacity cannot be set for PAY_PER_REQUEST billing mode'
        );
      }
    }
  }

  /**
   * Bestimmt RemovalPolicy basierend auf Stack-Name
   *
   * WARUM automatisch?
   * - Dev: DESTROY (schnelles Cleanup)
   * - Prod: RETAIN (Datenschutz)
   * - Manual Override möglich
   */
  private determineRemovalPolicy(
    customPolicy?: cdk.RemovalPolicy
  ): cdk.RemovalPolicy {
    if (customPolicy) {
      return customPolicy;
    }

    const stackName = cdk.Stack.of(this).stackName.toLowerCase();

    // Production Stack? → RETAIN
    if (
      stackName.includes('prod') ||
      stackName.includes('production') ||
      stackName.includes('live')
    ) {
      return cdk.RemovalPolicy.RETAIN;
    }

    // Dev/Test Stack → DESTROY
    return cdk.RemovalPolicy.DESTROY;
  }
}
