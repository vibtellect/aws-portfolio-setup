import { Construct } from 'constructs';
import * as cdk from 'aws-cdk-lib';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as kms from 'aws-cdk-lib/aws-kms';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as cloudwatch from 'aws-cdk-lib/aws-cloudwatch';

/**
 * Properties for DynamoDbTableStandard
 *
 * @example
 * ```ts
 * const props: DynamoDbTableStandardProps = {
 *   partitionKey: {
 *     name: 'userId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 *   sortKey: {
 *     name: 'todoId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 * };
 * ```
 */
export interface DynamoDbTableStandardProps {
  /**
   * Table name
   *
   * WARUM optional?
   * - CDK generiert automatisch eindeutigen Namen
   * - Nur setzen wenn spezifische Namenskonvention benötigt wird
   *
   * @default - Auto-generated by CDK
   */
  readonly tableName?: string;

  /**
   * Partition key (erforderlich)
   *
   * WARUM erforderlich?
   * - DynamoDB benötigt mindestens einen Partition Key
   * - Definiert wie Daten verteilt werden
   *
   * BEISPIEL:
   * ```ts
   * partitionKey: {
   *   name: 'userId',
   *   type: dynamodb.AttributeType.STRING,
   * }
   * ```
   */
  readonly partitionKey: dynamodb.Attribute;

  /**
   * Sort key (optional)
   *
   * WARUM optional?
   * - Nicht alle Tables benötigen Sort Key
   * - Nur wenn hierarchische Daten (z.B. userId + todoId)
   *
   * BEISPIEL:
   * ```ts
   * sortKey: {
   *   name: 'timestamp',
   *   type: dynamodb.AttributeType.NUMBER,
   * }
   * ```
   *
   * @default - No sort key
   */
  readonly sortKey?: dynamodb.Attribute;

  /**
   * Billing mode
   *
   * WARUM PAY_PER_REQUEST als Default?
   * - Kostenoptimiert für variable Workloads
   * - Keine Kapazitätsplanung nötig
   * - Free Tier: 25 WCU/RCU kostenlos
   *
   * @default BillingMode.PAY_PER_REQUEST
   */
  readonly billingMode?: dynamodb.BillingMode;

  /**
   * Read capacity (nur für PROVISIONED mode)
   *
   * @default - Not set (PAY_PER_REQUEST)
   */
  readonly readCapacity?: number;

  /**
   * Write capacity (nur für PROVISIONED mode)
   *
   * @default - Not set (PAY_PER_REQUEST)
   */
  readonly writeCapacity?: number;

  /**
   * Encryption key
   *
   * WARUM optional?
   * - AWS Managed Encryption ist Standard
   * - Customer Managed nur wenn Compliance nötig
   *
   * @default - AWS managed encryption
   */
  readonly encryptionKey?: kms.IKey;

  /**
   * Point-in-Time Recovery
   *
   * WARUM false als Default?
   * - Kostet extra (Backup Storage)
   * - Für Dev/Test meist nicht nötig
   * - Prod: empfohlen, aber optional
   *
   * @default false
   */
  readonly pointInTimeRecovery?: boolean;

  /**
   * Stream specification
   *
   * WARUM optional?
   * - Nur wenn Event-Driven Patterns benötigt
   * - z.B. Lambda Triggers, CDC
   *
   * @default - No stream
   */
  readonly stream?: dynamodb.StreamViewType;

  /**
   * Removal policy
   *
   * WARUM auto-detect?
   * - Dev: DESTROY (schnelles Cleanup)
   * - Prod: RETAIN (Datenschutz)
   *
   * @default - Auto-detect based on stack name
   */
  readonly removalPolicy?: cdk.RemovalPolicy;
}

/**
 * DynamoDB Table mit Production Best Practices
 *
 * WARUM dieser Construct?
 * 1. Kostenoptimierung: PAY_PER_REQUEST als Default
 * 2. Sicherheit: Encryption at Rest immer aktiviert
 * 3. Wartbarkeit: Environment-aware RemovalPolicy
 *
 * WAS macht er?
 * - Erstellt DynamoDB Table mit Best Practices
 * - Encryption at Rest (AWS oder Customer Managed)
 * - Optional: Streams, PITR, GSIs
 * - Environment-aware RemovalPolicy
 *
 * @example
 * ```ts
 * // Todo App Pattern
 * const table = new DynamoDbTableStandard(this, 'TodoTable', {
 *   partitionKey: {
 *     name: 'userId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 *   sortKey: {
 *     name: 'todoId',
 *     type: dynamodb.AttributeType.STRING,
 *   },
 *   pointInTimeRecovery: true, // Prod empfohlen
 * });
 * ```
 */
export class DynamoDbTableStandard extends Construct implements dynamodb.ITable {
  /**
   * Die innere DynamoDB Table (privat für Delegation)
   */
  private readonly _table: dynamodb.Table;

  // ========================================
  // ITable INTERFACE IMPLEMENTATION
  // ========================================

  /**
   * Arn of the dynamodb table.
   * @attribute
   */
  public readonly tableArn: string;

  /**
   * Table name of the dynamodb table.
   * @attribute
   */
  public readonly tableName: string;

  /**
   * ARN of the table's stream, if there is one.
   * @attribute
   */
  public readonly tableStreamArn?: string;

  /**
   * Optional KMS encryption key associated with this table.
   */
  public readonly encryptionKey?: kms.IKey;

  /**
   * The environment this resource belongs to.
   */
  public readonly env: cdk.ResourceEnvironment;

  /**
   * The stack in which this resource is defined.
   */
  public readonly stack: cdk.Stack;

  constructor(scope: Construct, id: string, props: DynamoDbTableStandardProps) {
    super(scope, id);

    // ========================================
    // 1. VALIDIERUNG
    // ========================================

    this.validateProps(props);

    // ========================================
    // 2. REMOVAL POLICY (Environment-aware)
    // ========================================

    const removalPolicy = this.determineRemovalPolicy(props.removalPolicy);

    // ========================================
    // 3. ENCRYPTION
    // ========================================

    const encryption = props.encryptionKey
      ? dynamodb.TableEncryption.CUSTOMER_MANAGED
      : dynamodb.TableEncryption.AWS_MANAGED;

    // ========================================
    // 4. DYNAMODB TABLE ERSTELLEN
    // ========================================

    this._table = new dynamodb.Table(this, 'Table', {
      tableName: props.tableName,

      // Keys
      partitionKey: props.partitionKey,
      sortKey: props.sortKey,

      // Billing
      billingMode: props.billingMode ?? dynamodb.BillingMode.PAY_PER_REQUEST,
      readCapacity: props.readCapacity,
      writeCapacity: props.writeCapacity,

      // Encryption
      encryption: encryption,
      encryptionKey: props.encryptionKey,

      // Backup & Recovery
      pointInTimeRecovery: props.pointInTimeRecovery ?? false,

      // Stream
      stream: props.stream,

      // Lifecycle
      removalPolicy: removalPolicy,
    });

    // ========================================
    // 5. TAGS
    // ========================================

    cdk.Tags.of(this._table).add('ManagedBy', 'CDK');
    cdk.Tags.of(this._table).add('Construct', 'DynamoDbTableStandard');

    // ========================================
    // 6. DELEGIERE ITable PROPERTIES
    // ========================================

    this.tableArn = this._table.tableArn;
    this.tableName = this._table.tableName;
    this.tableStreamArn = this._table.tableStreamArn;
    this.encryptionKey = this._table.encryptionKey;
    this.env = this._table.env;
    this.stack = this._table.stack;
  }

  // ========================================
  // ITable INTERFACE METHODS - Grant Permissions
  // ========================================

  /**
   * Adds an IAM policy statement associated with this table to an IAM principal's policy.
   */
  public grant(grantee: iam.IGrantable, ...actions: string[]): iam.Grant {
    return this._table.grant(grantee, ...actions);
  }

  /**
   * Adds an IAM policy statement associated with this table's stream to an IAM principal's policy.
   */
  public grantStream(grantee: iam.IGrantable, ...actions: string[]): iam.Grant {
    return this._table.grantStream(grantee, ...actions);
  }

  /**
   * Permits an IAM principal all data read operations from this table.
   */
  public grantReadData(grantee: iam.IGrantable): iam.Grant {
    return this._table.grantReadData(grantee);
  }

  /**
   * Permits an IAM Principal to list streams attached to current dynamodb table.
   */
  public grantTableListStreams(grantee: iam.IGrantable): iam.Grant {
    return this._table.grantTableListStreams(grantee);
  }

  /**
   * Permits an IAM principal all stream data read operations for this table's stream.
   */
  public grantStreamRead(grantee: iam.IGrantable): iam.Grant {
    return this._table.grantStreamRead(grantee);
  }

  /**
   * Permits an IAM principal all data write operations to this table.
   */
  public grantWriteData(grantee: iam.IGrantable): iam.Grant {
    return this._table.grantWriteData(grantee);
  }

  /**
   * Permits an IAM principal to all data read/write operations to this table.
   */
  public grantReadWriteData(grantee: iam.IGrantable): iam.Grant {
    return this._table.grantReadWriteData(grantee);
  }

  /**
   * Permits all DynamoDB operations ("dynamodb:*") to an IAM principal.
   */
  public grantFullAccess(grantee: iam.IGrantable): iam.Grant {
    return this._table.grantFullAccess(grantee);
  }

  // ========================================
  // ITable INTERFACE METHODS - Metrics
  // ========================================

  /**
   * Metric for the number of Errors executing all Lambdas.
   */
  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return this._table.metric(metricName, props);
  }

  /**
   * Metric for the consumed read capacity units.
   */
  public metricConsumedReadCapacityUnits(props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return this._table.metricConsumedReadCapacityUnits(props);
  }

  /**
   * Metric for the consumed write capacity units.
   */
  public metricConsumedWriteCapacityUnits(props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return this._table.metricConsumedWriteCapacityUnits(props);
  }

  /**
   * Metric for the system errors this table.
   */
  public metricSystemErrorsForOperations(props?: dynamodb.SystemErrorsForOperationsMetricOptions): cloudwatch.IMetric {
    return this._table.metricSystemErrorsForOperations(props);
  }

  /**
   * Metric for the user errors.
   */
  public metricUserErrors(props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return this._table.metricUserErrors(props);
  }

  /**
   * Metric for the conditional check failed requests.
   */
  public metricConditionalCheckFailedRequests(props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return this._table.metricConditionalCheckFailedRequests(props);
  }

  /**
   * Metric for throttled requests.
   * @deprecated use `metricThrottledRequestsForOperations`
   */
  public metricThrottledRequests(props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return this._table.metricThrottledRequests(props);
  }

  /**
   * Metric for throttled requests.
   */
  public metricThrottledRequestsForOperations(props?: dynamodb.OperationsMetricOptions): cloudwatch.IMetric {
    return this._table.metricThrottledRequestsForOperations(props);
  }

  /**
   * Metric for the successful request latency.
   */
  public metricSuccessfulRequestLatency(props?: cloudwatch.MetricOptions): cloudwatch.Metric {
    return this._table.metricSuccessfulRequestLatency(props);
  }

  // ========================================
  // IResource INTERFACE METHODS
  // ========================================

  /**
   * Apply the given removal policy to this resource
   */
  public applyRemovalPolicy(policy: cdk.RemovalPolicy): void {
    this._table.applyRemovalPolicy(policy);
  }

  // ========================================
  // PRIVATE METHODS
  // ========================================

  /**
   * Validiert die Props
   *
   * WARUM validieren?
   * - Frühzeitiges Feedback
   * - Bessere Fehlermeldungen
   * - Verhindert AWS API Errors
   */
  private validateProps(props: DynamoDbTableStandardProps): void {
    // Prüfe Partition Key
    if (!props.partitionKey) {
      throw new Error('Partition key is required');
    }

    // Prüfe Table-Name (AWS Limits)
    if (props.tableName && props.tableName.length > 255) {
      throw new Error('Table name must be <= 255 characters');
    }

    // Prüfe Table-Name Pattern (AWS erlaubt nur bestimmte Zeichen)
    if (props.tableName) {
      const validPattern = /^[a-zA-Z0-9._-]+$/;
      if (!validPattern.test(props.tableName)) {
        throw new Error('Table name must match pattern: [a-zA-Z0-9._-]+');
      }
    }

    // Prüfe Billing Mode + Capacity Settings
    if (props.billingMode === dynamodb.BillingMode.PROVISIONED) {
      if (!props.readCapacity || !props.writeCapacity) {
        throw new Error(
          'readCapacity and writeCapacity are required for PROVISIONED billing mode'
        );
      }
    }

    // Prüfe Capacity Settings bei PAY_PER_REQUEST
    if (
      props.billingMode === dynamodb.BillingMode.PAY_PER_REQUEST ||
      !props.billingMode
    ) {
      if (props.readCapacity || props.writeCapacity) {
        throw new Error(
          'readCapacity and writeCapacity cannot be set for PAY_PER_REQUEST billing mode'
        );
      }
    }
  }

  /**
   * Bestimmt RemovalPolicy basierend auf Stack-Name
   *
   * WARUM automatisch?
   * - Dev: DESTROY (schnelles Cleanup)
   * - Prod: RETAIN (Datenschutz)
   * - Manual Override möglich
   */
  private determineRemovalPolicy(
    customPolicy?: cdk.RemovalPolicy
  ): cdk.RemovalPolicy {
    if (customPolicy) {
      return customPolicy;
    }

    const stackName = cdk.Stack.of(this).stackName.toLowerCase();

    // Production Stack? → RETAIN
    if (
      stackName.includes('prod') ||
      stackName.includes('production') ||
      stackName.includes('live')
    ) {
      return cdk.RemovalPolicy.RETAIN;
    }

    // Dev/Test Stack → DESTROY
    return cdk.RemovalPolicy.DESTROY;
  }

  // ========================================
  // ADDITIONAL METHODS
  // ========================================

  /**
   * Access to the underlying dynamodb.Table for advanced use cases
   *
   * @internal
   */
  public get table(): dynamodb.Table {
    return this._table;
  }
}
