import { Construct } from 'constructs';
import * as cdk from 'aws-cdk-lib';
import * as sqs from 'aws-cdk-lib/aws-sqs';
import * as kms from 'aws-cdk-lib/aws-kms';

/**
 * Properties for SqsQueueEncrypted
 *
 * @example
 * ```ts
 * const props: SqsQueueEncrypted Props = {
 *   encryptionMasterKey: myKmsKey,
 *   retentionPeriod: Duration.days(7),
 *   enableDeadLetterQueue: true,
 * };
 * ```
 */
export interface SqsQueueEncryptedProps {
  /**
   * KMS Key für Queue-Verschlüsselung
   *
   * WARUM required?
   * - SSE-KMS ist ein Hauptfeature dieses Constructs
   * - Security Best Practice
   * - Compliance-Anforderungen
   *
   * @required
   */
  readonly encryptionMasterKey: kms.IKey;

  /**
   * Name der Queue
   *
   * WARUM optional?
   * - CDK generiert automatisch eindeutigen Namen
   * - Für FIFO Queues: .fifo wird automatisch angehängt
   *
   * @default - Auto-generated by CDK
   */
  readonly queueName?: string;

  /**
   * Message Retention Period
   *
   * WARUM 14 Tage Standard?
   * - Balance zwischen Kosten und Zuverlässigkeit
   * - AWS Best Practice für die meisten Use Cases
   *
   * @default Duration.days(14)
   */
  readonly retentionPeriod?: cdk.Duration;

  /**
   * Visibility Timeout
   *
   * WARUM wichtig?
   * - Zeit bis Message wieder sichtbar wird
   * - Sollte länger sein als Verarbeitungszeit
   *
   * @default Duration.seconds(30)
   */
  readonly visibilityTimeout?: cdk.Duration;

  /**
   * FIFO Queue aktivieren?
   *
   * WARUM optional?
   * - Nicht alle Use Cases brauchen Ordering
   * - FIFO Queues haben geringeren Throughput
   * - Höhere Kosten
   *
   * @default false
   */
  readonly fifo?: boolean;

  /**
   * Content-Based Deduplication
   *
   * WARUM nur für FIFO?
   * - Standard Queues haben keine Deduplication
   * - Verhindert doppelte Messages in FIFO
   *
   * @default false
   */
  readonly contentBasedDeduplication?: boolean;

  /**
   * Dead Letter Queue aktivieren?
   *
   * WARUM empfohlen?
   * - Fehlerhafte Messages isolieren
   * - Debugging vereinfachen
   * - Verhindert Message-Loop
   *
   * @default false
   */
  readonly enableDeadLetterQueue?: boolean;

  /**
   * Max Receive Count für DLQ
   *
   * WARUM 3 als Standard?
   * - Balance zwischen Retries und DLQ
   * - AWS Best Practice
   *
   * @default 3
   */
  readonly maxReceiveCount?: number;

  /**
   * RemovalPolicy für Queue
   *
   * WARUM wichtig?
   * - Dev: DESTROY (automatisch löschen)
   * - Prod: RETAIN (Messages behalten)
   *
   * @default - Auto-detect based on stack name
   */
  readonly removalPolicy?: cdk.RemovalPolicy;
}

/**
 * SQS Queue mit SSE-KMS Encryption
 *
 * WARUM dieser Construct?
 * 1. Sicherheit: KMS Encryption standardmäßig
 * 2. Standardisierung: Konsistente Queue-Konfiguration
 * 3. Best Practices: DLQ, Retention, Visibility Timeout
 *
 * WAS macht er?
 * - Erstellt SQS Queue mit SSE-KMS
 * - Optional: Dead Letter Queue
 * - Unterstützt FIFO Queues
 * - Environment-aware RemovalPolicy
 *
 * @example
 * ```ts
 * // Minimal (with KMS key)
 * const queue = new SqsQueueEncrypted(this, 'Queue', {
 *   encryptionMasterKey: myKmsKey,
 * });
 *
 * // With DLQ
 * const queue = new SqsQueueEncrypted(this, 'Queue', {
 *   encryptionMasterKey: myKmsKey,
 *   enableDeadLetterQueue: true,
 *   maxReceiveCount: 3,
 * });
 *
 * // FIFO Queue
 * const fifoQueue = new SqsQueueEncrypted(this, 'FifoQueue', {
 *   encryptionMasterKey: myKmsKey,
 *   fifo: true,
 *   contentBasedDeduplication: true,
 * });
 * ```
 */
export class SqsQueueEncrypted extends Construct {
  /**
   * Die erstellte SQS Queue
   *
   * WARUM public?
   * - Lambda-Functions brauchen die Queue als Event Source
   * - Andere Constructs müssen Permissions hinzufügen
   */
  public readonly queue: sqs.Queue;

  /**
   * ARN der Queue
   *
   * WARUM extra Property?
   * - Häufig benötigt für IAM Policies
   * - Für CloudFormation Outputs
   */
  public readonly queueArn: string;

  /**
   * URL der Queue
   *
   * WARUM extra Property?
   * - Benötigt für SDK-Calls (sendMessage, receiveMessage)
   * - Für Application Config
   */
  public readonly queueUrl: string;

  /**
   * Optional: Dead Letter Queue
   *
   * WARUM optional?
   * - Nur erstellt wenn enableDeadLetterQueue = true
   */
  public readonly deadLetterQueue?: sqs.DeadLetterQueue;

  constructor(scope: Construct, id: string, props: SqsQueueEncryptedProps) {
    super(scope, id);

    // ========================================
    // 1. VALIDIERUNG
    // ========================================

    this.validateProps(props);

    // ========================================
    // 2. DEFAULTS SETZEN
    // ========================================

    const retentionPeriod = props.retentionPeriod ?? cdk.Duration.days(14);
    const visibilityTimeout = props.visibilityTimeout ?? cdk.Duration.seconds(30);
    const removalPolicy = props.removalPolicy ?? this.getDefaultRemovalPolicy();
    const fifo = props.fifo ?? false;
    const contentBasedDeduplication = props.contentBasedDeduplication ?? false;

    // ========================================
    // 3. OPTIONAL: DEAD LETTER QUEUE
    // ========================================

    let deadLetterQueue: sqs.DeadLetterQueue | undefined;

    if (props.enableDeadLetterQueue) {
      const dlqQueueName = props.queueName
        ? `${props.queueName}-dlq${fifo ? '.fifo' : ''}`
        : undefined;

      const dlq = new sqs.Queue(this, 'DeadLetterQueue', {
        queueName: dlqQueueName,
        encryption: sqs.QueueEncryption.KMS,
        encryptionMasterKey: props.encryptionMasterKey,
        retentionPeriod: cdk.Duration.days(14), // DLQ should retain longer
        fifo,
        removalPolicy,
      });

      deadLetterQueue = {
        queue: dlq,
        maxReceiveCount: props.maxReceiveCount ?? 3,
      };

      this.deadLetterQueue = deadLetterQueue;

      // Tags für DLQ
      cdk.Tags.of(dlq).add('ManagedBy', 'CDK');
      cdk.Tags.of(dlq).add('Construct', 'SqsQueueEncrypted');
      cdk.Tags.of(dlq).add('Purpose', 'DeadLetterQueue');
    }

    // ========================================
    // 4. HAUPTQUEUE ERSTELLEN
    // ========================================

    // FIFO Queue: .fifo Suffix automatisch anhängen
    const finalQueueName = props.queueName
      ? fifo && !props.queueName.endsWith('.fifo')
        ? `${props.queueName}.fifo`
        : props.queueName
      : undefined;

    this.queue = new sqs.Queue(this, 'Queue', {
      queueName: finalQueueName,
      encryption: sqs.QueueEncryption.KMS,
      encryptionMasterKey: props.encryptionMasterKey,
      retentionPeriod,
      visibilityTimeout,
      fifo,
      contentBasedDeduplication: fifo ? contentBasedDeduplication : undefined,
      deadLetterQueue,
      removalPolicy,
    });

    // ========================================
    // 5. TAGS
    // ========================================

    cdk.Tags.of(this.queue).add('ManagedBy', 'CDK');
    cdk.Tags.of(this.queue).add('Construct', 'SqsQueueEncrypted');
    cdk.Tags.of(this.queue).add('Encrypted', 'true');
    cdk.Tags.of(this.queue).add('EncryptionType', 'KMS');

    // ========================================
    // 6. OUTPUTS
    // ========================================

    this.queueArn = this.queue.queueArn;
    this.queueUrl = this.queue.queueUrl;
  }

  /**
   * Validiert die Props
   *
   * WARUM validieren?
   * - Frühzeitiges Feedback
   * - Bessere Fehlermeldungen
   * - Verhindert AWS API Errors
   */
  private validateProps(props: SqsQueueEncryptedProps): void {
    // Encryption Key ist required
    if (!props.encryptionMasterKey) {
      throw new Error('Encryption master key is required for encrypted SQS queue');
    }

    // maxReceiveCount nur mit DLQ
    if (props.maxReceiveCount !== undefined && !props.enableDeadLetterQueue) {
      throw new Error('maxReceiveCount can only be set when enableDeadLetterQueue is true');
    }

    // Content-Based Deduplication nur für FIFO
    if (props.contentBasedDeduplication && !props.fifo) {
      throw new Error('contentBasedDeduplication can only be enabled for FIFO queues');
    }
  }

  /**
   * Ermittelt die Standard-RemovalPolicy basierend auf Stack-Name
   *
   * WARUM wichtig?
   * - Dev: DESTROY (automatisch löschen, spart Kosten)
   * - Prod: RETAIN (Messages behalten für Compliance)
   *
   * @returns RemovalPolicy.DESTROY für Dev, RETAIN für Prod
   */
  private getDefaultRemovalPolicy(): cdk.RemovalPolicy {
    const stackName = cdk.Stack.of(this).stackName.toLowerCase();

    const devPatterns = ['dev', 'test', 'sandbox', 'local', 'demo'];
    const isDev = devPatterns.some((pattern) => stackName.includes(pattern));

    return isDev ? cdk.RemovalPolicy.DESTROY : cdk.RemovalPolicy.RETAIN;
  }
}
